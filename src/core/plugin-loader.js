// src/core/plugin-loader.js
export class PluginLoader {
    constructor() {
        this.registry = [];
        this.plugins = new Map(); // id -> instance
        this.activePlugin = null;
    }

    /**
     * 1. Fetch the registry generated by the scanner
     */
    async loadRegistry() {
        try {
            const response = await fetch('/plugin-registry.json');
            if (!response.ok) throw new Error('Failed to load plugin registry');
            this.registry = await response.json();
            console.log(`üìã Registry loaded: ${this.registry.length} plugins found`);
            return this.registry;
        } catch (error) {
            console.error('Core Error:', error);
            return [];
        }
    }

    /**
     * 2. Dynamically import a specific plugin
     */
    async loadPlugin(pluginId) {
        const entry = this.registry.find(p => p.id === pluginId);
        if (!entry) throw new Error(`Plugin ${pluginId} not found in registry`);

        if (this.plugins.has(pluginId)) {
            return this.plugins.get(pluginId);
        }

        console.log(`üîå Loading plugin: ${entry.name}...`);
        
        try {
            // Dynamic import via Vite
            // Note: In production, these files must be in the build output
            const module = await import(/* @vite-ignore */ entry.path);
            
            // Instantiate the plugin class (Default Export)
            const PluginClass = module.default;
            const instance = new PluginClass();
            
            // Lifecycle: Init
            if (typeof instance.init === 'function') {
                await instance.init();
            }

            this.plugins.set(pluginId, instance);
            return instance;
        } catch (error) {
            console.error(`‚ùå Failed to load ${pluginId}:`, error);
            throw error;
        }
    }
}

export const pluginLoader = new PluginLoader();